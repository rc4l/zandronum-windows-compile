name: Test DLL Detection

on:
  workflow_dispatch: # Allows you to trigger the workflow manually from the Actions tab

jobs:
  test-static-linking:
    runs-on: windows-latest
    name: "Test Static Linking (Should Pass)"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run Zandronum build script with static linking
        shell: pwsh
        run: |
          Write-Host "Building with static linking (should pass DLL check)..."
          ./build.ps1

      - name: Remove system Python from PATH
        run: |
          $paths = $env:PATH -split ";"
          $filteredPaths = $paths | Where-Object { $_ -notmatch "(?i)python|pip|conda|anaconda" }
          $env:PATH = $filteredPaths -join ";"
          Write-Host "Filtered PATH: $env:PATH"

      - name: DLL dependency verification
        run: |
          Write-Host "=== DLL Dependency Verification ==="
          $zandronumPath = ".\build\Release\zandronum.exe"
          
          # Method 1: Use dumpbin to check dependencies
          Write-Host "`n--- Method 1: Static dependency analysis ---"
          try {
            $vsPath = Get-ChildItem "C:\Program Files*" -Filter "Microsoft Visual Studio" -Directory | Select-Object -First 1
            if ($vsPath) {
              $dumpbinPath = Get-ChildItem $vsPath.FullName -Recurse -Filter "dumpbin.exe" | Select-Object -First 1
              if ($dumpbinPath) {
                Write-Host "Using dumpbin to check dependencies..."
                $dependencies = & $dumpbinPath.FullName /dependents $zandronumPath 2>&1
                $dependencies | Write-Host
                
                # Check for dynamic OpenSSL dependencies
                $sslDeps = $dependencies | Select-String -Pattern "(libssl|libcrypto|ssl|crypto).*\.dll" -CaseSensitive
                if ($sslDeps) {
                  Write-Host "❌ Found dynamic SSL dependencies:"
                  $sslDeps | Write-Host
                  exit 1
                } else {
                  Write-Host "✅ No dynamic SSL dependencies found"
                }
              }
            }
          } catch {
            Write-Host "dumpbin check failed: $_"
          }
          
          # Method 2: Use PowerShell's own assembly loading to check for missing dependencies
          Write-Host "`n--- Method 2: Isolated environment test ---"
          
          # Create a minimal isolated environment script
          $testScript = @'
          try {
            # Try to load the PE file and check if all imports can be resolved
            Add-Type -TypeDefinition @"
              using System;
              using System.Runtime.InteropServices;
              public class NativeMethods {
                [DllImport("kernel32.dll", SetLastError = true)]
                public static extern IntPtr LoadLibrary(string lpFileName);
                
                [DllImport("kernel32.dll", SetLastError = true)]
                public static extern bool FreeLibrary(IntPtr hModule);
                
                [DllImport("kernel32.dll")]
                public static extern uint GetLastError();
              }
"@
            
            $handle = [NativeMethods]::LoadLibrary($args[0])
            $error = [NativeMethods]::GetLastError()
            
            if ($handle -eq [IntPtr]::Zero) {
              Write-Host "LoadLibrary failed with error: $error"
              # Common Windows error codes:
              # 126 = The specified module could not be found
              # 127 = The specified procedure could not be found  
              # 193 = not a valid Win32 application
              if ($error -eq 126) {
                Write-Host "ERROR: Missing DLL dependency detected (Error 126)"
                exit 1
              } elseif ($error -eq 127) {
                Write-Host "ERROR: Missing procedure in DLL (Error 127)"
                exit 1
              } else {
                Write-Host "ERROR: LoadLibrary failed with error code $error"
                exit 1
              }
            } else {
              Write-Host "✅ LoadLibrary succeeded - all dependencies available"
              [NativeMethods]::FreeLibrary($handle) | Out-Null
            }
          } catch {
            Write-Host "ERROR: Exception during dependency check: $_"
            exit 1
          }
'@
          
          # Clear PATH to simulate clean environment
          $originalPath = $env:PATH
          try {
            $env:PATH = "C:\Windows\System32;C:\Windows;C:\Windows\System32\Wbem"
            
            # Run the test in a new PowerShell process with the minimal environment
            $result = powershell.exe -Command "& { $testScript }" -ArgumentList $zandronumPath
            Write-Host $result
            
            if ($LASTEXITCODE -ne 0) {
              Write-Host "❌ Dependency test failed with exit code: $LASTEXITCODE"
              exit 1
            }
            
          } finally {
            $env:PATH = $originalPath
          }
          
          # Method 3: Try to actually run the executable with minimal error handling
          Write-Host "`n--- Method 3: Runtime execution test ---"
          try {
            $env:PATH = "C:\Windows\System32;C:\Windows;C:\Windows\System32\Wbem"
            
            # Use timeout command to limit execution time and capture any immediate startup errors
            $output = cmd.exe /c "timeout /t 2 /nobreak >nul & echo Starting executable... & .\build\Release\zandronum.exe -iwad nonexistent.wad 2>&1"
            Write-Host "Execution output:"
            Write-Host $output
            
            # Check for common DLL error patterns in Windows
            if ($output -match "(?i)(is missing|not found|could not be located|entry point.*could not be located)" -or
                $output -match "(?i)(libssl|libcrypto).*dll" -or 
                $output -match "(?i)0xc0000135") {  # STATUS_DLL_NOT_FOUND
              Write-Host "❌ Runtime DLL dependency error detected"
              exit 1
            }
            
            Write-Host "✅ No runtime DLL errors detected"
            
          } finally {
            $env:PATH = $originalPath
          }
          
          Write-Host "`n✅ All DLL dependency tests passed!"

  test-dynamic-linking:
    runs-on: windows-latest
    name: "Test Dynamic Linking (Should Fail)"
    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Run Zandronum build script with dynamic linking
        shell: pwsh
        run: |
          Write-Host "Building with dynamic linking (should fail DLL check)..."
          ./build.ps1 -TestDynamicLinking

      - name: Remove system Python from PATH
        run: |
          $paths = $env:PATH -split ";"
          $filteredPaths = $paths | Where-Object { $_ -notmatch "(?i)python|pip|conda|anaconda" }
          $env:PATH = $filteredPaths -join ";"
          Write-Host "Filtered PATH: $env:PATH"

      - name: Remove OpenSSL from system (to force DLL error)
        run: |
          Write-Host "Removing any system OpenSSL DLLs to force dependency failure..."
          # Remove any OpenSSL DLLs that might be in system paths
          Get-ChildItem "C:\Windows\System32" -Filter "*ssl*.dll" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Found system SSL DLL: $($_.FullName)"
            try {
              Rename-Item $_.FullName "$($_.FullName).bak" -Force
              Write-Host "Renamed to .bak"
            } catch {
              Write-Host "Could not rename (may be in use): $_"
            }
          }
          
          Get-ChildItem "C:\Windows\System32" -Filter "*crypto*.dll" -ErrorAction SilentlyContinue | ForEach-Object {
            Write-Host "Found system crypto DLL: $($_.FullName)"
            try {
              Rename-Item $_.FullName "$($_.FullName).bak" -Force
              Write-Host "Renamed to .bak"
            } catch {
              Write-Host "Could not rename (may be in use): $_"
            }
          }

      - name: DLL dependency verification (expected to fail)
        run: |
          Write-Host "=== DLL Dependency Verification (Expected to Fail) ==="
          $zandronumPath = ".\build\Release\zandronum.exe"
          
          # This test should FAIL because we built with dynamic linking and removed system OpenSSL
          $testFailed = $false
          
          # Method 1: Use dumpbin to check dependencies
          Write-Host "`n--- Method 1: Static dependency analysis ---"
          try {
            $vsPath = Get-ChildItem "C:\Program Files*" -Filter "Microsoft Visual Studio" -Directory | Select-Object -First 1
            if ($vsPath) {
              $dumpbinPath = Get-ChildItem $vsPath.FullName -Recurse -Filter "dumpbin.exe" | Select-Object -First 1
              if ($dumpbinPath) {
                Write-Host "Using dumpbin to check dependencies..."
                $dependencies = & $dumpbinPath.FullName /dependents $zandronumPath 2>&1
                $dependencies | Write-Host
                
                # Check for dynamic OpenSSL dependencies
                $sslDeps = $dependencies | Select-String -Pattern "(libssl|libcrypto|ssl|crypto).*\.dll" -CaseSensitive
                if ($sslDeps) {
                  Write-Host "✅ Found dynamic SSL dependencies (as expected for this test):"
                  $sslDeps | Write-Host
                } else {
                  Write-Host "❌ ERROR: No dynamic SSL dependencies found - static linking may have been used instead"
                  $testFailed = $true
                }
              }
            }
          } catch {
            Write-Host "dumpbin check failed: $_"
          }
          
          # Method 2: Runtime test should fail
          Write-Host "`n--- Method 2: Runtime execution test (should fail) ---"
          try {
            $originalPath = $env:PATH
            $env:PATH = "C:\Windows\System32;C:\Windows;C:\Windows\System32\Wbem"
            
            # Use timeout command to limit execution time and capture any immediate startup errors
            $output = cmd.exe /c "echo Starting executable... & .\build\Release\zandronum.exe -iwad nonexistent.wad 2>&1"
            Write-Host "Execution output:"
            Write-Host $output
            
            # Check for common DLL error patterns in Windows - these SHOULD be present
            if ($output -match "(?i)(is missing|not found|could not be located|entry point.*could not be located)" -or
                $output -match "(?i)(libssl|libcrypto).*dll" -or 
                $output -match "(?i)0xc0000135") {  # STATUS_DLL_NOT_FOUND
              Write-Host "✅ Runtime DLL dependency error detected (as expected for this test)"
            } else {
              Write-Host "❌ ERROR: No runtime DLL errors detected - this suggests system OpenSSL DLLs are still available"
              $testFailed = $true
            }
            
            $env:PATH = $originalPath
            
          } catch {
            Write-Host "✅ Runtime test failed with exception (as expected): $_"
          }
          
          if ($testFailed) {
            Write-Host "`n❌ TEST FAILED: Dynamic linking test did not behave as expected"
            Write-Host "This suggests either:"
            Write-Host "1. Static linking was used despite the -TestDynamicLinking flag"
            Write-Host "2. System OpenSSL DLLs are still available on the runner"
            exit 1
          } else {
            Write-Host "`n✅ Dynamic linking test behaved as expected (found dependencies/errors)"
          }

      - name: Restore system DLLs
        if: always()
        run: |
          Write-Host "Restoring any renamed DLLs..."
          Get-ChildItem "C:\Windows\System32" -Filter "*.dll.bak" -ErrorAction SilentlyContinue | ForEach-Object {
            $originalName = $_.FullName -replace "\.bak$", ""
            try {
              Rename-Item $_.FullName $originalName -Force
              Write-Host "Restored: $originalName"
            } catch {
              Write-Host "Could not restore $originalName : $_"
            }
          }
